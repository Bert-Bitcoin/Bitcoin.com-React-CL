import { transform } from '@svgr/core';
import camelcase from 'camelcase';
import { readdir, readFile, writeFile, mkdir, rm } from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';

const projectRoot = path.resolve(process.cwd());
const svgSourceDir = path.resolve(projectRoot, 'src', 'mini-illustrations');
const outputDir = path.resolve(projectRoot, 'src', 'components', 'mini-illustrations');

const HEADER = [
  '// This file was generated by scripts/generate-mini-illustrations.ts',
  '// Do not edit manually.'
].join('\n');

async function generateMiniIllustrations() {
  await mkdir(outputDir, { recursive: true });

  const existing = await readdir(outputDir);
  await Promise.all(
    existing
      .filter(
        (file) =>
          file.toLowerCase().endsWith('.tsx') &&
          !file.toLowerCase().endsWith('.stories.tsx')
      )
      .map((file) => rm(path.join(outputDir, file)))
  );

  const files = await readdir(svgSourceDir);
  const svgFiles = files.filter((file) => file.toLowerCase().endsWith('.svg'));

  if (svgFiles.length === 0) {
    console.warn('[mini-illustrations] No SVG files found in src/mini-illustrations.');
    return;
  }

  const exportLines: string[] = [HEADER];
  const usedNames = new Set<string>();
  const nameCounter = new Map<string, number>();

  for (const file of svgFiles) {
    const filePath = path.join(svgSourceDir, file);
    const svgCode = await readFile(filePath, 'utf8');
    const baseName = path.basename(file, path.extname(file));
    
    // Remove "mini-illustration-" prefix and clean the name
    // Preserve underscores as a special character to maintain uniqueness
    const cleanedName = baseName
      .replace(/^(mini[\-_]?illustration[\-_]?)/i, '')
      .replace(/_/g, 'Underscore')
      .replace(/\s+/g, ' ')
      .trim();
    
    let componentBaseName = camelcase(cleanedName, {
      pascalCase: true,
      preserveConsecutiveUppercase: true
    }).replace(/[^A-Za-z0-9]/g, '');
    
    if (!componentBaseName) {
      componentBaseName = 'Illustration';
    }
    if (/^[0-9]/.test(componentBaseName)) {
      componentBaseName = `Illustration${componentBaseName}`;
    }
    
    let componentName = `${componentBaseName}Illustration`;
    
    // Handle duplicates by appending a number
    if (usedNames.has(componentName)) {
      const count = (nameCounter.get(componentBaseName) || 1) + 1;
      nameCounter.set(componentBaseName, count);
      componentName = `${componentBaseName}${count}Illustration`;
    }
    
    usedNames.add(componentName);

    let componentCode = await transform(
      svgCode,
      {
        icon: false,
        typescript: true,
        prettier: false,
        memo: false,
        jsxRuntime: 'automatic',
        exportType: 'named',
        namedExport: componentName,
        plugins: ['@svgr/plugin-svgo', '@svgr/plugin-jsx'],
        svgoConfig: {
          plugins: [
            {
              name: 'removeAttrs',
              params: { attrs: '(data-name)' }
            }
          ]
        }
      },
      { componentName }
    );

    if (!componentCode.includes(HEADER)) {
      componentCode = `${HEADER}\n${componentCode}`;
    }
    
    componentCode += `\n${componentName}.displayName = '${componentName}';\n`;

    const outputPath = path.join(outputDir, `${componentName}.tsx`);
    await writeFile(outputPath, componentCode, 'utf8');
    exportLines.push(`export { ${componentName} } from './${componentName}';`);
  }

  exportLines.push('');

  const indexPath = path.join(outputDir, 'index.ts');
  await writeFile(indexPath, `${exportLines.join('\n')}\n`, 'utf8');

  console.info(`[mini-illustrations] Generated ${svgFiles.length} mini-illustration components.`);
}

await generateMiniIllustrations();

