# Cursor AI Rules for Design System Integration
# Project: React + Tailwind + Tokens + Figma MCP + Storybook

## Project Metadata

- **Figma Design File**: https://www.figma.com/design/whUdbUxyPxMpIMbTapDqdn/Web-component-library--AI-?node-id=17998-17298&t=fCYrU0ejGmjVXf4L-1
- **Icons Path**: `src/icons`
- **Fonts Path**: `src/fonts`
- **Tokens Path**: `src/tokens`
- **Tailwind Config**: `tailwind.config.ts`
- **Component Path**: `src/components`
- **Storybook Static Dir**: `storybook-static`
- **Sync Scripts**: `scripts/sync-figma-tokens.ts`, `scripts/generate-icons.ts`
- **Theme Strategy**: `tailwind-dark-mode-class`

---

## ü§ñ AI Agent Consumption Rules

### Rule: ai-guide-adherence (REQUIRED)
For detailed implementation patterns, strictly follow [AI_CONSUMPTION_GUIDE.md](./AI_CONSUMPTION_GUIDE.md). This file contains the "Gold Standard" for code generation in this project.

### Rule: semantic-tokens-only (STRICT)
AI Agents must NEVER generate code with raw hex values or standard Tailwind colors (e.g., `bg-blue-500`). ALWAYS use the project's semantic tokens (e.g., `bg-primary-100`, `text-surface`).

### Rule: strict-typography-mapping (STRICT)
- **Headings**: Always `Elza` + `uppercase` (e.g., `text-heading-lg`).
- **Numbers**: Always `IBM Plex Sans` (e.g., `text-numeric`).
- **Body**: `Satoshi` (e.g., `text-body`).

### Rule: listitem-for-lists (STRICT)
When generating any list-style UI (menus, settings lists, asset lists, step-by-step lists, transaction lists, etc.), **always try to use** the existing `ListItem` component (`src/components/list-item/ListItem.tsx`) instead of custom list markup.

- Prefer tweaking via `ListItem` options/props (`size`, `number`, `illustration` + `illustrationType`, `leftContent`, `rightContent`, `indicator`, `buttonArea`, `showDivider`, `onClick`) before creating new list row layouts.
- Only use custom markup if `ListItem` cannot support the design; if so, document why and still reuse library components for sub-elements.

---

## üîó Figma Design System Integration

### Rule: figma-mpc-sync (REQUIRED)
Sync Figma design tokens and components via `scripts/sync-figma-tokens.ts`. Ensure names and tokens map 1:1.

### Rule: figma-child-component-reuse (STRICT)
When creating new components from Figma via the Figma MCP server, always inspect the Figma component hierarchy for child components and verify whether those child parts already exist in the React Component Library (`src/components`). If matching components exist (e.g., buttons, icons, tabs, inputs, logos, mini-illustrations), reuse the existing React components instead of re-implementing them, and compose the new component from these building blocks.

### Rule: figma-component-variations (STRICT)
Before creating or modifying a component, **always check the Figma component library** for defined variations (e.g., sizes, states, variants). Respect and implement all variations exactly as specified in Figma. Component props and variants in code must match Figma's component structure. Use Figma MCP tools to inspect component variations and states.

### Rule: figma-component-grouping (STRICT)
Always follow the component grouping and organization as defined in the Figma design file (https://www.figma.com/design/whUdbUxyPxMpIMbTapDqdn/Web-component-library--AI-). When creating or organizing components in the codebase and Storybook, mirror the exact grouping structure from Figma. This ensures consistency between design and development. Component categories, subcategories, and naming conventions must match the Figma file structure.

Example Figma groupings to follow:
- **Design System** - Colors, tokens, theme variables
- **Foundation** - Icons, typography, illustrations, spacing
- **Components** - Grouped by function (Form Elements, UI Elements, etc.)

Reference: [Figma Web Component Library](https://www.figma.com/design/whUdbUxyPxMpIMbTapDqdn/Web-component-library--AI-?node-id=17998-17298&t=fCYrU0ejGmjVXf4L-1)

---

## üé® Tailwind & Tokens

### Rule: tailwind-token-usage (STRICT)
Use Tailwind utility classes **only** when backed by values from `src/tokens` or Tailwind config. Avoid arbitrary values unless mirrored from Figma tokens.

### Rule: prefer-token-class (STRICT)
Prefer using `className` with tokenized Tailwind utilities (e.g., `text-token-heading-lg`) over inline styles.

### Rule: no-hardcoded-css (STRICT)
Do not use hardcoded `style={{ ... }}` props for spacing, color, or typography unless absolutely required.

### Rule: color-palette-only (STRICT)
Only use colors that are defined in the design system color palette (found in `src/tokens` or `src/components/colorpalette`). No custom colors, hex values, or arbitrary color values are allowed outside of the approved color palette. All color usage must reference tokenized color values from the design system.

---

## üåó Theming

### Rule: no-dark-variants (STRICT)
**NEVER use `dark:` Tailwind utility classes** when generating new components or Storybook UI. Dark mode is handled automatically through CSS variables defined in the token system. The design tokens already contain both light and dark mode values that switch based on the theme class applied to the root element. Using `dark:` classes is redundant and not needed.

Example:
```tsx
// Correct - semantic tokens handle dark mode automatically
<div className="bg-surface text-on-surface">Content</div>

// Incorrect - do NOT use dark: variants
<div className="bg-white dark:bg-gray-900 text-black dark:text-white">Content</div>
```

### Rule: theme-support (STRICT)
Ensure all components support both light and dark themes using CSS variables from the token system. Dark mode is automatically handled by semantic tokens - no `dark:` utility classes needed.

### Rule: validate-tailwind-themes (RECOMMENDED)
Ensure both themes render correctly using `tailwind.config.ts` theme extensions and CSS vars from tokens.

### Rule: figma-dark-mode-colors (STRICT)
Each color defined in Figma has a corresponding dark mode variant. Always implement both light and dark color variants for each component, matching the Figma design system's color definitions. When syncing tokens or creating components, ensure every color token has its dark mode counterpart applied.

---

## üìÅ File/Folder Structure

### Rule: component-structure (REQUIRED)
Follow `src/components/ComponentName/Component.tsx` + co-located `stories.tsx`, `test.tsx`, and `index.ts` structure.

Example:
```
src/components/Button/
  - Button.tsx
  - Button.stories.tsx
  - Button.test.tsx
  - index.ts
```

### Rule: script-placement (RECOMMENDED)
Token and icon sync scripts should live in `scripts/` folder and be self-documented.

### Rule: guides-folder-structure (REQUIRED)
All comprehensive documentation guides (implementation guides, reference documents, change summaries, etc.) MUST be created in the `guides/` folder. The only exception is `AI_CONSUMPTION_GUIDE.md` which remains at the root level as the main entry point. When creating new guides:
- Store them in `guides/` folder with descriptive ALL_CAPS names (e.g., `NEW_FEATURE_GUIDE.md`)
- Add a reference to the new guide in the `AI_CONSUMPTION_GUIDE.md` under the "Additional Guides" section
- Organize guides by category (Typography, SEO, Components, etc.) in the reference list
- Ensure all guides are discoverable through `AI_CONSUMPTION_GUIDE.md`

Example guide structure:
```
guides/
  - ELZA_TYPOGRAPHY_GUIDELINES.md
  - SEO_IMPROVEMENTS_PRIORITY_1.md
  - MODAL_IMPLEMENTATION_SUMMARY.md
  - [NEW_GUIDE_NAME].md
```

When referencing guides, use relative paths: `./guides/GUIDE_NAME.md`

---

## üì¶ Icon & Font Asset Rules

### Rule: icon-usage (STRICT)
Use only icons from `src/icons`. Each must be imported from the `index.ts` barrel file.

### Rule: font-usage (STRICT)
Fonts must be loaded from `src/fonts` and referenced via Tailwind `extend.fontFamily` config.

### Rule: elza-font-capitalization (STRICT)
When using the Elza font family (Elza, Elza Narrow) on any HTML element or component, the text content **must always be capitalized**. The Elza font is used for display and heading text in the design system. All typography tokens that use Elza (display, heading-xl, heading-lg, heading-md, heading-sm) have `textTransform: 'uppercase'` built-in. If manually applying Elza font, always add the Tailwind `uppercase` class or `text-transform: uppercase` CSS property.

Example:
```tsx
// Correct - using typography token (uppercase is automatic)
<h1 className="text-display">Bitcoin Rewards</h1>

// Correct - manually applying Elza with uppercase
<h1 className="font-['Elza_Narrow'] uppercase">Bitcoin Rewards</h1>

// Incorrect - missing uppercase when manually using Elza
<h1 className="font-['Elza_Narrow']">Bitcoin Rewards</h1>
```

### Rule: elza-font-line-height (STRICT)
**All Elza font usage MUST use `leading-[0.94]` for line-height.** This applies to:
- All heading elements (h1, h2, h3, etc.) using Elza Narrow font
- All display text using Elza font
- All typography tokens (display-xl, heading-xl, heading-lg, heading-md, heading-sm)
- Any manual usage of `font-['Elza_Narrow']` or `font-['Elza']`

The standard line-height of `0.94` ensures consistent tight leading across all Elza typography, creating the intended visual hierarchy and spacing.

**Implementation:**
```tsx
// Correct - with leading-[0.94]
<h1 className="font-['Elza_Narrow'] text-[70px] uppercase leading-[0.94]">
  Bitcoin Rewards
</h1>

// Correct - using typography token (leading-[0.94] is built-in)
<h1 className="text-display">Bitcoin Rewards</h1>

// Incorrect - missing or wrong line-height
<h1 className="font-['Elza_Narrow'] text-[70px] uppercase leading-none">
  Bitcoin Rewards
</h1>

// Incorrect - using different line-height value
<h1 className="font-['Elza_Narrow'] text-[70px] uppercase leading-tight">
  Bitcoin Rewards
</h1>
```

**Typography Token Line Heights:**
All typography tokens that use Elza font have been updated to use `lineHeight: '0.94'`:
- `display-xl` - lineHeight: '0.94'
- `heading-xl` - lineHeight: '0.94'
- `heading-lg` - lineHeight: '0.94'
- `heading-md` - lineHeight: '0.94'
- `heading-sm` - lineHeight: '0.94'

When using these tokens (e.g., `text-display`, `text-heading-lg`), the correct line-height is automatically applied.

### Rule: ibm-plex-sans-numeric (STRICT)
**Always use IBM Plex Sans font for displaying numeric values** (numbers, prices, amounts, quantities, percentages, etc.). IBM Plex Sans is designed for optimal readability of numbers and should be applied to any content that contains numeric data. Use the `font-['IBMPlexSans']` class or ensure your typography token uses IBM Plex Sans when rendering numeric content.

Example:
```tsx
// Correct - using IBM Plex Sans for numeric values
<span className="font-['IBMPlexSans']">$1,234.56</span>
<div className="font-['IBMPlexSans']">42.5%</div>
<p className="font-['IBMPlexSans']">0.00012345 BTC</p>

// Incorrect - not using IBM Plex Sans for numbers
<span className="font-satoshi">$1,234.56</span>
<div>42.5%</div>
```

This applies to:
- Cryptocurrency amounts and prices
- Fiat currency values
- Percentages
- Quantities and counts
- Transaction amounts
- Wallet balances
- Any numeric data display

---

## üß© Component Development

### Rule: typescript-enforcement (STRICT)
All components must be written in TypeScript (`.tsx`) and fully typed. No `any` types unless absolutely necessary.

### Rule: accessibility-baseline (RECOMMENDED)
Use semantic HTML and ARIA roles where applicable. Buttons must be real `<button>` elements, not divs with click handlers.

---

## üåê Website Sections Components

### Rule: website-sections-responsive-padding (STRICT)
All "website sections" components must implement responsive vertical padding following these exact breakpoint rules:
- **Mobile** (default): `py-[32px]`
- **Small**: `sm:py-[40px]`
- **Medium**: `md:py-[60px]`
- **Large**: `lg:py-[80px]`

Use the following responsive Tailwind classes:
```tsx
<section className="py-[32px] sm:py-[40px] md:py-[60px] lg:py-[80px]">
  {/* content */}
</section>
```

### Rule: website-sections-h2-styling (STRICT)
All H2 headings within "website sections" components must use the following exact styling:
```tsx
<h2 className="font-['Elza_Narrow'] text-[32px] md:text-[44px] lg:text-[70px] uppercase leading-none">
  Heading Text
</h2>
```

This ensures consistent typography across all website sections with:
- **Font**: Elza Narrow
- **Mobile size**: 32px
- **Tablet size**: 44px (md breakpoint)
- **Desktop size**: 70px (lg breakpoint)
- **Transform**: Uppercase
- **Line height**: None (leading-none)

### Rule: website-sections-content-width (STRICT)
Content within "website sections" components must follow these width constraints:
- **Maximum width**: `1240px` (use `max-w-[1240px]`)
- **Minimum width**: Full width (use `w-full`)
- **Centering**: Content should be horizontally centered using `mx-auto`

Implementation pattern:
```tsx
<section className="py-m md:py-l">
  <div className="w-full max-w-[1240px] mx-auto">
    {/* section content */}
  </div>
</section>
```

### Rule: website-sections-naming (RECOMMENDED)
Website section components should be named descriptively and stored in `src/components/` with a clear indication they are section components (e.g., `HeroSection`, `FeaturesSection`, `TestimonialsSection`, etc.).

### Rule: website-sections-editable-content (STRICT)
**All text content within website section components MUST be editable/optional through component props.** Never hardcode text strings, labels, titles, descriptions, or any user-facing content directly in the component implementation. This ensures maximum flexibility for content authors and enables easy customization for different pages, locales, or use cases.

**Required Implementation:**

1. **All Text Content as Props**: Every piece of text that appears in the component must have a corresponding optional prop with a sensible default value.

2. **Include All Text Types**:
   - Headings (h1, h2, h3, etc.)
   - Body text and descriptions
   - Button labels and CTA text
   - Link labels
   - Form labels and placeholders
   - Aria labels and accessibility text
   - Legal/copyright text
   - Image alt text
   - Any other user-facing text

3. **Provide Sensible Defaults**: All text props should be optional with meaningful default values that demonstrate the component's purpose.

**Example Implementation:**

```typescript
interface WebsiteSectionProps {
  // Main content text
  heading?: string;
  subheading?: string;
  description?: string;
  
  // CTA/Button text
  ctaLabel?: string;
  ctaHref?: string;
  
  // Accessibility
  sectionAriaLabel?: string;
  
  // ... other props
}

export const WebsiteSection = ({
  heading = 'Default Heading',
  subheading = 'Default Subheading',
  description = 'Default description text',
  ctaLabel = 'Learn More',
  ctaHref = '#',
  sectionAriaLabel = 'Website Section',
  // ... other props with defaults
}: WebsiteSectionProps) => {
  return (
    <section aria-label={sectionAriaLabel}>
      <h2>{heading}</h2>
      <h3>{subheading}</h3>
      <p>{description}</p>
      <a href={ctaHref}>{ctaLabel}</a>
    </section>
  );
};
```

**Documentation Requirements:**
- Document all text props in the component's README
- Include examples showing how to customize all text content
- Show complete customization examples in Storybook stories

**Why This Matters:**
- Enables content reuse across different pages
- Supports internationalization/localization efforts
- Allows marketing teams to test different copy
- Makes components truly reusable and flexible
- Prevents need for component duplication for minor text changes

**Reference Implementation:**
See `src/components/website-footer/WebsiteFooter.tsx` for a complete example of this pattern, including editable `downloadTitle`, `legalText`, `logoAriaLabel`, and all link labels through the `linkGroups` prop.

### Rule: website-sections-editable-links (STRICT)
**All links (URLs/hrefs) within website section components MUST be editable/customizable through component props.** Never hardcode URLs, link destinations, or navigation paths directly in the component implementation. This ensures components can be reused across different pages, environments, and use cases without modification.

**Required Implementation:**

1. **All Links as Props**: Every link/URL in the component must be customizable through props with sensible default values.

2. **Include All Link Types**:
   - Call-to-action (CTA) button links
   - Navigation links
   - External resource links (social media, documentation, etc.)
   - Download links (app stores, files, PDFs)
   - Footer links
   - Image links
   - Logo links
   - Any other clickable elements that navigate

3. **Provide Flexible Link Structures**: For components with multiple links, use structured data (arrays, objects) to allow full customization:

```typescript
interface LinkItem {
  label: string;
  href: string;
  isExternal?: boolean;
  onClick?: () => void;
}

interface LinkGroup {
  heading: string;
  links: LinkItem[];
}

interface WebsiteSectionProps {
  // Single link props
  ctaLabel?: string;
  ctaHref?: string;
  
  // Multiple links via arrays
  navigationLinks?: LinkItem[];
  
  // Grouped links
  linkGroups?: LinkGroup[];
  
  // Specific link overrides
  googlePlayHref?: string;
  appStoreHref?: string;
  
  // ... other props
}
```

**Example Implementation:**

```typescript
export const WebsiteSection = ({
  ctaLabel = 'Get Started',
  ctaHref = '#',
  navigationLinks = [
    { label: 'About', href: '/about' },
    { label: 'Contact', href: '/contact' }
  ],
  googlePlayHref = 'https://play.google.com/store/apps/details?id=com.example',
  appStoreHref = 'https://apps.apple.com/app/example/id123456789',
  // ... other props
}: WebsiteSectionProps) => {
  return (
    <section>
      {/* CTA button with editable link */}
      <a href={ctaHref}>{ctaLabel}</a>
      
      {/* Navigation with editable links */}
      <nav>
        {navigationLinks.map((link) => (
          <a key={link.href} href={link.href}>{link.label}</a>
        ))}
      </nav>
      
      {/* App store buttons with editable links */}
      <a href={googlePlayHref}>Google Play</a>
      <a href={appStoreHref}>App Store</a>
    </section>
  );
};
```

**Documentation Requirements:**
- Document all link props in the component's README
- Show examples of customizing single and multiple links
- Document link structure types (LinkItem, LinkGroup, etc.)
- Include examples in Storybook stories

**Why This Matters:**
- Enables reuse across different environments (dev, staging, production)
- Supports A/B testing different landing pages or destinations
- Allows dynamic routing based on user context
- Makes components environment-agnostic
- Supports deep linking and custom navigation flows
- Prevents hardcoded URLs that break when routes change

**Common Link Prop Patterns:**

1. **Single CTA Links:**
```typescript
ctaHref?: string;
primaryButtonHref?: string;
learnMoreHref?: string;
```

2. **App Store Links:**
```typescript
googlePlayHref?: string;
appStoreHref?: string;
```

3. **Social Media Links:**
```typescript
twitterHref?: string;
linkedInHref?: string;
discordHref?: string;
```

4. **Multiple Links (Arrays):**
```typescript
links?: Array<{ label: string; href: string }>;
navigationLinks?: LinkItem[];
footerLinks?: LinkItem[];
```

5. **Grouped Links:**
```typescript
linkGroups?: Array<{
  heading: string;
  links: Array<{ label: string; href: string }>;
}>;
```

**Reference Implementation:**
See `src/components/website-footer/WebsiteFooter.tsx` for a complete example of this pattern, including:
- `googlePlayHref` and `appStoreHref` for app store badges
- `linkGroups` array for footer navigation with custom hrefs
- Flexible link structure allowing complete customization of all URLs

### Rule: website-sections-remove-top-padding (STRICT)
All website section components MUST include a `removeTopPadding` prop to allow seamless stacking of sections with the same background style. This is essential for creating continuous content flow without large gaps.

**Required Props:**
```typescript
interface WebsiteSectionProps {
  // ... other props
  
  /**
   * Remove top padding - useful when stacking sections with the same style
   * @default false
   */
  removeTopPadding?: boolean;
}
```

**Implementation Pattern:**
```tsx
export const WebsiteSection = ({
  // ... other props
  removeTopPadding = false
}: WebsiteSectionProps) => {
  return (
    <section
      className={twMerge(
        'px-m md:px-xl',
        removeTopPadding 
          ? 'pb-[32px] sm:pb-[40px] md:pb-[60px] lg:pb-[80px]'
          : 'py-[32px] sm:py-[40px] md:py-[60px] lg:py-[80px]',
        // ... other classes
      )}
    >
      {/* section content */}
    </section>
  );
};
```

**When to use `removeTopPadding={true}`:**
- Stacking multiple sections with the same background style
- Creating continuous content flow
- Reducing visual gaps between related sections

**When NOT to use:**
- First section on a page (should have normal top padding)
- Sections with different background styles (the gap helps separate them)

**Example Usage:**
```tsx
// First section - normal padding
<HeroSection style="light" />

// Second section - same style, remove top padding
<FeaturesSection style="light" removeTopPadding={true} />

// Third section - different style, normal padding
<CTASection style="black" />
```

---

## üîç SEO & Semantic HTML (CRITICAL)

### Rule: website-sections-seo-requirements (STRICT)
All website section components MUST implement the following SEO best practices to ensure maximum search engine visibility and optimal SEO scores. These requirements are MANDATORY for all new website section components and should be verified before considering a component complete.

#### **1. Section ID Prop (REQUIRED)**
Every website section component MUST include an optional `id` prop for anchor linking and deep navigation:

```typescript
interface SectionProps {
  // ... other props

  /**
   * Optional ID for the section element (useful for anchor links and SEO)
   * Enables deep linking like: yoursite.com/page#section-id
   */
  id?: string;
}
```

Apply to section element:
```tsx
<section id={id} className="...">
  {/* content */}
</section>
```

#### **2. Structured Data / Schema Markup (REQUIRED for content sections)**
Content-heavy sections (articles, news, FAQs, reviews, products) MUST implement Schema.org structured data using JSON-LD:

**Required Props:**
```typescript
interface ContentSectionProps {
  // ... other props

  /**
   * Enable structured data (Schema.org) for SEO
   * @default true
   */
  enableStructuredData?: boolean;
}
```

**Implementation Pattern:**
```tsx
const structuredData = enableStructuredData ? {
  "@context": "https://schema.org",
  "@type": "AppropriateSchemaType",
  // ... schema properties
} : null;

return (
  <section id={id}>
    {structuredData && (
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(structuredData) }}
      />
    )}
    {/* section content */}
  </section>
);
```

**Schema Types by Section:**
- **FAQSection**: Use `FAQPage` schema with `Question`/`Answer` entities
- **ArticlesSection**: Use `ItemList` with `Article` entities
- **NewsSection**: Use `ItemList` with `NewsArticle` entities
- **ReviewsSection**: Use `Review` or `AggregateRating` schema
- **ProductSection**: Use `Product` schema with offers
- **EventSection**: Use `Event` schema

**Reference**: [SEO_IMPROVEMENTS_PRIORITY_1.md](./SEO_IMPROVEMENTS_PRIORITY_1.md) for implementation examples.

#### **3. Semantic HTML Elements (REQUIRED)**
Use proper HTML5 semantic elements for content structure:

**Article/News Content:**
```tsx
// ‚úÖ CORRECT - Use <article> for article/news cards
<article className="card">
  <a href={article.href}>
    <img ... />
    <h3>{article.title}</h3>
    <p>{article.summary}</p>
    <time dateTime={article.datePublished}>...</time>
  </a>
</article>

// ‚ùå INCORRECT - Don't use generic divs
<div className="card">
  <a href={article.href}>...</a>
</div>
```

**Always use:**
- `<article>` for article/news/blog cards
- `<time datetime="...">` for dates and timestamps
- `<section>` for page sections (already standard)
- `<header>` for section headers when appropriate
- `<nav>` for navigation elements
- `<aside>` for sidebars or supplementary content

#### **4. Image Optimization (STRICT)**
All images in website sections MUST include SEO and performance attributes:

**Required Image Attributes:**
```tsx
<img
  src={imageUrl}
  alt={imageAlt || `${title} - Descriptive context`}  // REQUIRED: Descriptive alt text
  width={imageWidth || defaultWidth}                   // REQUIRED: Explicit width
  height={imageHeight || defaultHeight}                // REQUIRED: Explicit height
  loading="lazy"                                       // REQUIRED: For non-hero images
  className="..."
/>
```

**Hero/Above-Fold Images:**
```tsx
<img
  src={heroImage}
  alt="Descriptive alt text"
  width={1200}
  height={630}
  loading="eager"  // Use "eager" for hero images
  fetchPriority="high"  // Optional: prioritize hero images
  className="..."
/>
```

**Image Prop Requirements:**
```typescript
interface ImageContent {
  imageUrl: string;
  imageAlt?: string;         // Optional: falls back to descriptive default
  imageWidth?: number;       // Optional: falls back to sensible default
  imageHeight?: number;      // Optional: falls back to sensible default
}
```

**Alt Text Best Practices:**
- NEVER leave alt text empty (except for purely decorative images)
- Provide context: `${title} - Article image` not just `title`
- Describe the image content when custom alt is not provided
- For decorative images only: use `alt=""` (empty string)

#### **5. Time Elements for Dates (REQUIRED)**
All dates and timestamps MUST use HTML5 `<time>` element with `datetime` attribute:

**Implementation:**
```tsx
// ‚úÖ CORRECT
<time dateTime={article.datePublished}>
  {formatDate(article.datePublished)}
</time>

// ‚úÖ CORRECT - With relative time
{article.datePublished ? (
  <time dateTime={article.datePublished}>
    {article.timestamp || formatDate(article.datePublished)}
  </time>
) : article.timestamp ? (
  <span>{article.timestamp}</span>
) : null}

// ‚ùå INCORRECT - Missing time element
<span>{article.timestamp}</span>
<div>{formatDate(article.date)}</div>
```

**Required Type Enhancement:**
```typescript
interface Article {
  // ... other props

  /**
   * Publication date in ISO 8601 format (e.g., "2024-01-16T10:00:00Z")
   * Used for structured data and time element
   */
  datePublished?: string;

  /**
   * Human-readable timestamp (e.g., "2 hours ago")
   * Falls back to formatted datePublished if not provided
   */
  timestamp?: string;
}
```

#### **6. Accessibility & ARIA (REQUIRED)**
Ensure all interactive elements have proper ARIA labels and semantic meaning:

```tsx
// Navigation buttons
<button
  onClick={handleScroll}
  aria-label="Scroll to next article"  // REQUIRED: Descriptive label
  disabled={!canScroll}
>
  <Icon type="icon-right-arrow" ariaHidden />  // Mark icon as decorative
</button>

// Section relationships
<section id="articles" aria-labelledby="articles-heading">
  <h2 id="articles-heading">Latest Articles</h2>
  {/* content */}
</section>
```

#### **7. SEO Props Checklist**
When creating a new website section component, ensure these props are included:

**Base Props (All Sections):**
```typescript
interface WebsiteSectionProps {
  /** Optional ID for anchor linking */
  id?: string;

  /** Theme mode */
  themeMode?: 'auto' | 'light' | 'dark';

  /** Additional CSS classes */
  className?: string;
}
```

**Content Section Props (Articles/News/FAQs/etc.):**
```typescript
interface ContentSectionProps extends WebsiteSectionProps {
  /** Enable structured data for SEO */
  enableStructuredData?: boolean; // Default: true
}
```

**Article/News Item Props:**
```typescript
interface ArticleItem {
  id: string;
  title: string;
  summary: string;
  imageUrl?: string;
  imageAlt?: string;
  imageWidth?: number;     // NEW: For SEO
  imageHeight?: number;    // NEW: For SEO
  href?: string;
  author?: string;         // NEW: For schema
  datePublished?: string;  // NEW: For schema & time element (ISO 8601)
  timestamp?: string;      // Optional: Human-readable time
}
```

---

### Rule: seo-validation-checklist (STRICT)
Before marking a website section component as complete, verify ALL of the following:

**‚úÖ Required SEO Features:**
- [ ] `id` prop defined in types and applied to `<section>` element
- [ ] Structured data implemented (if content section) with `enableStructuredData` prop
- [ ] All article/news items wrapped in `<article>` tags
- [ ] All dates use `<time datetime="...">` elements
- [ ] All images have `alt`, `width`, `height`, and `loading` attributes
- [ ] Alt text is descriptive with contextual fallbacks
- [ ] Hero images use `loading="eager"`, other images use `loading="lazy"`
- [ ] Interactive elements have proper ARIA labels
- [ ] TypeScript types include all SEO-related props
- [ ] Component documentation mentions SEO features

**‚úÖ Testing Requirements:**
- [ ] Validate structured data with [Google Rich Results Test](https://search.google.com/test/rich-results)
- [ ] Check schema with [Schema.org Validator](https://validator.schema.org/)
- [ ] Run Lighthouse audit (target: 90+ SEO score)
- [ ] Verify Core Web Vitals (good CLS with image dimensions)
- [ ] Test anchor links work correctly
- [ ] Verify semantic HTML structure with accessibility tree

**‚úÖ Documentation:**
- [ ] Update component README with SEO features
- [ ] Add examples showing SEO props usage
- [ ] Document structured data output in Storybook
- [ ] Include anchor link examples

---

### Rule: seo-implementation-priority (STRICT)
SEO requirements are CRITICAL and must be implemented in Priority 1 (not "later" or "optional"):

**Priority 1 (MANDATORY - Must be implemented):**
1. Section `id` prop
2. Structured data for content sections
3. Semantic HTML (`<article>`, `<time>`)
4. Image optimization (width, height, loading, alt)
5. Descriptive alt text with fallbacks
6. Time elements for dates

**Priority 2 (Recommended - Implement if applicable):**
1. ARIA labels for complex interactions
2. Section heading relationships (`aria-labelledby`)
3. Focus management for interactive elements

**Priority 3 (Nice to have):**
1. Breadcrumb schema
2. Site navigation schema
3. Additional metadata

**NEVER skip Priority 1 SEO requirements.** They directly impact search rankings, Core Web Vitals, and user experience.

---

## üìö Storybook Integration

### Rule: storybook-sync (REQUIRED)
Every component must have an up-to-date Storybook story (`*.stories.tsx`) covering default, variants, and both themes.

### Rule: storybook-controls (RECOMMENDED)
Expose all component props using `argTypes` and Storybook Controls for interactive documentation.

### Rule: storybook-dark-mode (REQUIRED)
Use Storybook theming addon or wrapper to preview light/dark styles consistently.

### Rule: storybook-component-reuse (STRICT)
When creating Storybook stories, **always reuse existing components from the component library** for any supporting UI elements in examples. Never create custom markup or one-off UI elements when an existing component can be used. This includes but is not limited to: Cards, Tables, Buttons, Inputs, Icons, Tabs, Modals, Typography, Layouts, etc. This ensures consistency across stories, reduces code duplication, and demonstrates real-world component composition patterns.

Example:
```tsx
// Correct - reusing existing Card and Button components
export const ExampleStory: Story = {
  render: (args) => (
    <Card variant="outlined">
      <YourComponent {...args} />
      <Button variant="primary">Action</Button>
    </Card>
  ),
};

// Incorrect - creating custom markup instead of using existing components
export const ExampleStory: Story = {
  render: (args) => (
    <div className="border rounded p-4">
      <YourComponent {...args} />
      <div className="bg-primary-500 px-4 py-2">Action</div>
    </div>
  ),
};
```

Before creating any supporting UI in a story, check `src/components/` to see if a suitable component already exists.

### Rule: no-external-placeholder-images (STRICT)
**NEVER use external placeholder image services** (e.g., `via.placeholder.com`, `placeholder.com`, `placekitten.com`, `lorempixel.com`) in Storybook stories or component examples. These services are unreliable, may be blocked by network policies, or fail to load, resulting in broken examples.

**Instead, use one of these approved alternatives:**

1. **Gradient Divs with Icons/Emojis** (Preferred for demos):
```tsx
<div className="w-full aspect-[360/200] bg-gradient-to-br from-[#0052FF] to-[#0041CC] rounded-[8px] flex items-center justify-center">
  <div className="text-center text-white">
    <div className="text-[48px] mb-2">‚Çø</div>
    <div className="font-['Satoshi_Variable'] font-semibold text-sm">Bitcoin</div>
  </div>
</div>
```

2. **Inline SVG Data URIs** (For actual image elements):
```tsx
<img
  src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='360' height='200'%3E%3Crect fill='%230052FF' width='360' height='200'/%3E%3Ctext fill='white' x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24'%3EPlaceholder%3C/text%3E%3C/svg%3E"
  alt="Placeholder"
/>
```

3. **Solid Color Backgrounds** (Simple placeholders):
```tsx
<div className="w-full aspect-[360/200] bg-shades-extra-light rounded-[8px] flex items-center justify-center">
  <span className="text-shades-semi-dark font-['Satoshi_Variable']">Image Placeholder</span>
</div>
```

4. **Mini-Illustrations** (For feature/product cards):
```tsx
import { BitcoinCreditCardsIllustration } from '../mini-illustrations';

<div className="w-full aspect-[360/200] bg-shades-extra-light rounded-[8px] p-l flex items-center justify-center">
  <BitcoinCreditCardsIllustration className="w-[120px] h-[120px]" />
</div>
```

**Why this matters:**
- External services can be blocked by corporate firewalls or content policies
- Network failures cause broken images in documentation
- Adds external dependencies to the project
- May have rate limiting or availability issues
- Self-contained examples are more reliable and professional

**Always prefer self-contained, locally-rendered placeholders** that work offline and don't depend on external services.

---

## üîÅ Change Sync Behavior

### Rule: token-sync-watch (REQUIRED)
When `src/tokens` changes or `scripts/sync-figma-tokens.ts` is run, affected components and stories must be re-evaluated for consistency.

### Rule: icon-regeneration (REQUIRED)
Run `scripts/generate-icons.ts` when icon assets in `src/icons` are changed to refresh the icon set.

---

## Implementation Guidelines

### When Creating New Components:
1. **Check Figma first** - Use Figma MCP tools to inspect the component's variations, properties, and states
2. **Verify component grouping** - Check the [Figma file](https://www.figma.com/design/whUdbUxyPxMpIMbTapDqdn/Web-component-library--AI-?node-id=17998-17298&t=fCYrU0ejGmjVXf4L-1) to see which category the component belongs to
3. Create folder in `src/components/ComponentName/`
4. Create `ComponentName.tsx` with full TypeScript types matching Figma variants
5. Create `ComponentName.stories.tsx` with the correct Storybook path matching Figma grouping
6. Export from `index.ts`
7. Use only token-based Tailwind classes
8. Support both light and dark themes
9. Test accessibility with semantic HTML

### When Inspecting Figma Components:
1. Open the [Figma design file](https://www.figma.com/design/whUdbUxyPxMpIMbTapDqdn/Web-component-library--AI-?node-id=17998-17298&t=fCYrU0ejGmjVXf4L-1) to identify component location and grouping
2. Use `mcp_Figma_Desktop_get_design_context` to view component structure and variations
3. Use `mcp_Figma_Desktop_get_variable_defs` to see design tokens applied to variants
4. Use `mcp_Figma_Desktop_get_screenshot` to visually reference the component
5. Document all variants found (e.g., size: sm/md/lg, state: default/hover/disabled)
6. Note the component's category/grouping in Figma for proper Storybook organization
7. Ensure TypeScript props/types align with Figma component properties

### When Modifying Styles:
1. Check if tokens exist in `src/tokens` first
2. Use Tailwind utilities backed by tokens
3. Avoid arbitrary values like `text-[#123456]`
4. **Only use colors from the approved color palette** - no custom hex values or arbitrary colors
5. **NEVER use `dark:` variants** - dark mode is handled automatically by semantic tokens
6. **For display/heading text** - use typography tokens (text-display, text-heading-xl, etc.) which have Elza font and uppercase built-in
7. **When manually using Elza font** - always add `uppercase` class for capitalization
8. Test in both light and dark modes

### When Syncing Design Tokens:
1. Run `scripts/sync-figma-tokens.ts`
2. Review changes in `src/tokens/generated.ts`
3. Update affected components if token names changed
4. Rebuild Storybook to verify visual consistency

### When Adding Icons:
1. Add SVG to `src/icons`
2. Run `scripts/generate-icons.ts`
3. Import from `src/components/icons/index.ts`
4. Use consistent naming conventions

### When Creating Storybook Stories:
1. Review existing components in `src/components/` before creating any supporting UI
2. **Always reuse existing components** for wrapper elements, containers, and interactive elements
3. Use existing components to demonstrate real-world composition patterns
4. Common components to reuse in stories:
   - `Card` - for wrapping examples or showing component context
   - `Button` - for interactive actions in examples
   - `Table` - for displaying tabular data in examples
   - `Tabs` - for organizing multiple example variants
   - `Modal` or `Window` - for overlay/dialog examples
   - `Typography` components - for text content in examples
   - `Icon` - for visual elements
   - Layout components (`WebLayout`, `WebAppLayout`) - for full-page examples
5. Import and compose existing components rather than creating custom markup
6. Document component composition patterns that users can learn from
7. Ensure all supporting components use the same theming and token system

### When Creating Website Sections:
1. Create folder in `src/components/SectionName/` (e.g., `HeroSection`, `FeaturesSection`)
2. Implement the required props structure with **SEO props** (CRITICAL):
   ```tsx
   interface SectionNameProps {
     themeMode?: 'auto' | 'light' | 'dark';
     id?: string;  // REQUIRED: For anchor linking
     removeTopPadding?: boolean;  // REQUIRED: For stacking sections (default: false)
     enableStructuredData?: boolean;  // REQUIRED: For content sections (default: true)
     // ... component-specific props
   }

   // For article/news items, include SEO metadata:
   interface ArticleItem {
     id: string;
     title: string;
     imageUrl?: string;
     imageAlt?: string;
     imageWidth?: number;      // NEW: For performance
     imageHeight?: number;     // NEW: For performance
     author?: string;          // NEW: For schema
     datePublished?: string;   // NEW: For schema (ISO 8601)
     // ... other props
   }
   ```
3. Apply the standard wrapper structure with correct padding, **id prop**, and **removeTopPadding**:
   ```tsx
   <section
     id={id}  // REQUIRED: Add id prop
     className={cn(
       'px-m md:px-xl',
       removeTopPadding 
         ? 'pb-[32px] sm:pb-[40px] md:pb-[60px] lg:pb-[80px]'
         : 'py-[32px] sm:py-[40px] md:py-[60px] lg:py-[80px]',
       themeMode === 'light' && 'light',
       themeMode === 'dark' && 'dark'
     )}
   >
     {/* REQUIRED: Add structured data for content sections */}
     {structuredData && (
       <script
         type="application/ld+json"
         dangerouslySetInnerHTML={{ __html: JSON.stringify(structuredData) }}
       />
     )}

     <div className="w-full max-w-[1240px] mx-auto">
       {/* Section content goes here */}
     </div>
   </section>
   ```
4. Style all H2 headings with the standard section heading format:
   ```tsx
   <h2 className="font-['Elza_Narrow'] text-[32px] md:text-[44px] lg:text-[70px] uppercase leading-none">
     Section Heading
   </h2>
   ```
5. **Wrap article/news items in semantic `<article>` tags** (REQUIRED):
   ```tsx
   <article className="card">
     <a href={article.href}>
       <img
         src={article.imageUrl}
         alt={article.imageAlt || `${article.title} - Article image`}
         width={article.imageWidth || 451}
         height={article.imageHeight || 280}
         loading="lazy"
       />
       <h3>{article.title}</h3>
       <p>{article.summary}</p>
       {article.datePublished && (
         <time dateTime={article.datePublished}>
           {formatDate(article.datePublished)}
         </time>
       )}
     </a>
   </article>
   ```
6. **Optimize all images** with width, height, loading, and descriptive alt text (REQUIRED)
7. **Use `<time>` elements** for all dates with `datetime` attribute (REQUIRED)
8. Use semantic tokens for all colors and spacing within the content
9. Create Storybook stories showing all three theme modes (auto, light, dark)
10. Reuse existing components from the component library for section content
11. Test responsive behavior at mobile, tablet, and desktop breakpoints
12. Ensure accessibility with proper semantic HTML5 section elements
13. **Validate SEO implementation** (REQUIRED):
    - Test structured data with [Google Rich Results Test](https://search.google.com/test/rich-results)
    - Run Lighthouse audit (target: 90+ SEO score)
    - Verify Core Web Vitals in PageSpeed Insights
    - Check anchor links work correctly

**Reference**: See [SEO_IMPROVEMENTS_PRIORITY_1.md](./SEO_IMPROVEMENTS_PRIORITY_1.md) for detailed implementation examples and best practices.
